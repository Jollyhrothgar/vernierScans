#ifndef __HOURGLASS_CONFIGURATION__
#define __HOURGLASS_CONFIGURATION__

#include<string>
#include <map>
class HourglassConfiguration{
 public:
  std::string this_name;
  HourglassConfiguration();
  ~HourglassConfiguration();
  int GenerateEmptyConfigFile();
  
  //  LoadConfigFile:
  // no checking is done to see if all config parameters are present, so
  // partial files may be loaded to enable mutliple sources to generate config
  // parameters.
  int LoadConfigFile(const std::string& in_file_name); 
  
  int ModifyConfigParameter(const std::string& param, const std::string& val);
  int SaveConfigFile(const std::string& out_file);
  int ShowConfigFile();
  int SetDefaultValues();

  // Returns the value mapped to key, par_name, in par_
  std::string GetPar( const std::string&  par_name );

  // Returns a copy of the config map
  std::map<std::string,std::string> GetAllPar() {return par_;};

  // BatchCreateConfigFiles
  // This member creates all the configuration files neccessary for simulating
  // the vertex profile of each individual scan step. Because of the nature of
  // the vernier scan, we take data for scanned steps sequentially, therefore,
  // files zdc_counts_per_step_file, x_offsets_file and y_offsets_file contain
  // configuration parameters for several steps. Beam widths are handled with
  // the h_width_file and v_width file (h = horizontal, v = vertical), and beam
  // populations for the blue and yellow beams are stored in
  // beam_population_file.
  //
  // In summary, we give this class configuration information for all the data
  // sources from a single vernier scan, which are automatically generated by
  // classes which work with that data.
  //
  // WcmDcctManager : creates beam_population_file
  // HourglassData  : creates zdc_counts_per_step_file 
  // BeamWidthTime  : creates [xy]_offsets_file, [hv]_width_file
  //
  // In batch mode, we keep the name for the scan step more simple. Simply
  // [RunNumber]_step[StepNumber].conf is sufficient, since it is too cumbersome
  // to include significan configuration information in the file-name itself,
  // and these config files will be starting points for simulation, rather than
  // the final best configuration.
  int BatchCreateConfigFiles(
    const std::string& run_number_,
    const std::string& bbc_zdc_offset_file,
    const std::string& zdc_counts_per_step_file,
    const std::string& x_offsets_file,
    const std::string& y_offsets_file,
    const std::string& h_width_file,
    const std::string& v_width_file,
    const std::string& beam_population_file, 
    const std::string& zdc_vertex_histo_name_file,
    const std::string& sim_config_out_dir
  );

  // Used for generating config files to farm out simulations to cluster - start
  // with a good config file, then set the tolerance range for range of
  // parameters. This function can be modified to determine which parameters are
  // varied, but currently, it makes sense to vary beta-star, multiple
  // collisions, crossing angle and z-scale. But maybe not even multiple
  // collisions.
  //
  // base_config is the base config file which will be modified. 
  //
  // out_directory is where we will deposit the config files
  //
  // stub is the base name for the config file
  //
  // pct_range gives the percentage of the range to vary a parameter's value.
  // For example, if you give it 0.5, then the parameters will be varied from
  // par-0.5*par to par+0.5*par.
  //
  // steps will tell how many steps to split up the range into. The minimum is
  // three, such that you get one file for the low range, one file for the
  // middle of the range, and one file for the top of the range. 
  //
  // Files will be generated and named based on stub. Appended to the stub will
  // be an integer, representing the order the config files were generated. This
  // is simply to provide a unique name to the file. For example, say you have
  // three parameters which are varied 3 times each, then you will have 3 choose
  // 3 parameters, i.e. 9 files. Then the files will be called:
  // out_directory/run_number_stub_n.conf where n varies from 0 to 8.
  int GenerateConfigFileRange(
      const std::string& base_config, 
      const std::string& out_directory, 
      const std::string& stub, 
      double pct_range, 
      double steps
   );

  // Generate a unique config file name from identifying information
  std::string GetConfigName();

  // returns true if par is found to be a parameter in config_. Designed usage
  // is for checking input when loading partial parameter lists from files.
  bool ParameterExists(const std::string& par);
 private:
  // string representation of hourglass simulation parameters
  std::map<std::string,std::string> par_;
};

#endif
